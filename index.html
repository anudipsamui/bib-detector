<script type="module">
import { InferenceEngine, CVImage } from "https://cdn.jsdelivr.net/npm/inferencejs@1.1.3/dist/inferencejs.min.js";

// Roboflow model
const MODEL_NAME = "bib-number-labeling";
const MODEL_VERSION = "2";
const PUBLISHABLE_KEY = "rf_3HHrpOkdE4arP6EJhtDqcxZMpyf1";

const inferEngine = new InferenceEngine();
const workerId = await inferEngine.startWorker(MODEL_NAME, MODEL_VERSION, PUBLISHABLE_KEY);

const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");

const results = [];
const ocrQueue = new Set();
let detectionInterval;
let stream;

// --- Web Worker for Tesseract OCR ---
const ocrWorker = Tesseract.createWorker({
    logger: m => console.log(m)
});
await ocrWorker.load();
await ocrWorker.loadLanguage('eng');
await ocrWorker.initialize('eng');
await ocrWorker.setParameters({ tessedit_char_whitelist: '0123456789' });

async function startDetection() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } });
        video.srcObject = stream;
        video.style.display = "block";
        await video.play();
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        detectionInterval = setInterval(processFrame, 1000); // faster detection
        startBtn.disabled = true;
        stopBtn.disabled = false;
        startBtn.innerText = "üé• Detecting...";
    } catch(err) {
        alert("Camera access failed: " + err.message);
        console.error(err);
    }
}

function stopDetection() {
    if(stream) stream.getTracks().forEach(track => track.stop());
    video.style.display = "none";
    ctx.clearRect(0,0,overlay.width,overlay.height);
    clearInterval(detectionInterval);
    startBtn.disabled = false;
    stopBtn.disabled = true;
    startBtn.innerText = "‚ñ∂Ô∏è Start Detection";
}

async function processFrame() {
    if (!video.videoWidth) return;
    const cvimg = new CVImage(video);
    const predictions = await inferEngine.infer(workerId, cvimg);

    ctx.clearRect(0,0,overlay.width, overlay.height);

    for (const p of predictions) {
        const { x, y, width, height } = p.bbox;
        let detectedBib = false;
        for(const r of results){
            if(Math.abs(r.x - x)<10 && Math.abs(r.y - y)<10){ detectedBib = true; break; }
        }

        ctx.strokeStyle = detectedBib ? "green" : "red";
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, width, height);
        ctx.font = "18px Arial";
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fillText(p.className + " " + Math.round(p.confidence*100)+"%", x, y-5);

        const key = `${x}_${y}_${width}_${height}`;
        if(!ocrQueue.has(key)){
            ocrQueue.add(key);
            (async () => {
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = width/2; // downscale for speed
                cropCanvas.height = height/2;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(video, x, y, width, height, 0, 0, cropCanvas.width, cropCanvas.height);
                const cropDataUrl = cropCanvas.toDataURL();

                const { data: { text } } = await ocrWorker.recognize(cropDataUrl);
                const bib = text.match(/\d{2,6}/)?.[0];
                if(bib && !results.find(r=>r.bib===bib)){
                    const timestamp = new Date().toLocaleString();
                    results.push({ bib, timestamp, x, y });
                    const row = document.getElementById("resultsTable").insertRow();
                    row.insertCell(0).innerText = bib;
                    row.insertCell(1).innerText = timestamp;
                }
                ocrQueue.delete(key);
            })();
        }
    }
}

function downloadCSV() {
    let csv = "BIB,Timestamp\n";
    results.forEach(r => csv += `${r.bib},${r.timestamp}\n`);
    const blob = new Blob([csv], {type:"text/csv"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "bib_results.csv";
    a.click();
}

startBtn.addEventListener("click", startDetection);
stopBtn.addEventListener("click", stopDetection);
</script>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BIB Detector</title>
<script src="https://cdn.jsdelivr.net/npm/inferencejs@1.1.3"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
body { font-family:sans-serif; text-align:center; background:#fafafa; margin:0; padding:20px;}
h1 { margin-bottom:10px }
#videoContainer { position:relative; display:inline-block; margin-top:20px; }
video { width:90%; max-width:400px; border-radius:12px; box-shadow:0 0 10px #888; display:none; }
canvas { position:absolute; top:0; left:0; pointer-events:none; }
table { margin:20px auto; border-collapse:collapse; width:80%; max-width:500px;}
th, td { border:1px solid #ccc; padding:8px; }
button { margin:6px; padding:10px 18px; border:none; border-radius:8px; background:#007bff; color:#fff; font-weight:bold;}
button:hover { background:#0056b3;}
</style>
</head>
<body>

<h1>üèÉ‚Äç‚ôÇÔ∏è Live BIB Detector</h1>
<button id="startBtn">‚ñ∂Ô∏è Start Detection</button>
<button id="stopBtn" disabled>‚èπ Stop Detection</button>

<div id="videoContainer">
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<table id="resultsTable">
<tr><th>BIB</th><th>Timestamp</th></tr>
</table>
<button onclick="downloadCSV()">‚¨áÔ∏è Download CSV</button>

<script type="module">
(async () => {
    const { InferenceEngine, CVImage } = await import("https://cdn.jsdelivr.net/npm/inferencejs@1.1.3/dist/inferencejs.min.js");

    const MODEL_NAME = "bib-number-labeling";
    const MODEL_VERSION = "2";
    const PUBLISHABLE_KEY = "rf_3HHrpOkdE4arP6EJhtDqcxZMpyf1";

    const inferEngine = new InferenceEngine();
    const workerId = await inferEngine.startWorker(MODEL_NAME, MODEL_VERSION, PUBLISHABLE_KEY);

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");

    const results = [];
    const ocrQueue = new Set();
    let detectionInterval;
    let stream;

    const ocrWorker = Tesseract.createWorker();
    await ocrWorker.load();
    await ocrWorker.loadLanguage('eng');
    await ocrWorker.initialize('eng');
    await ocrWorker.setParameters({ tessedit_char_whitelist: '0123456789' });

    async function startDetection() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } });
            video.srcObject = stream;
            video.style.display = "block";
            await video.play();
            overlay.width = video.videoWidth;
            overlay.height = video.videoHeight;
            detectionInterval = setInterval(processFrame, 1000);
            startBtn.disabled = true;
            stopBtn.disabled = false;
            startBtn.innerText = "üé• Detecting...";
        } catch(err) {
            alert("Camera access failed: " + err.message);
            console.error(err);
        }
    }

    function stopDetection() {
        if(stream) stream.getTracks().forEach(track => track.stop());
        video.style.display = "none";
        ctx.clearRect(0,0,overlay.width,overlay.height);
        clearInterval(detectionInterval);
        startBtn.disabled = false;
        stopBtn.disabled = true;
        startBtn.innerText = "‚ñ∂Ô∏è Start Detection";
    }

    async function processFrame() {
        if (!video.videoWidth) return;
        const cvimg = new CVImage(video);
        const predictions = await inferEngine.infer(workerId, cvimg);
        ctx.clearRect(0,0,overlay.width, overlay.height);

        for (const p of predictions) {
            const { x, y, width, height } = p.bbox;
            let detectedBib = results.some(r => Math.abs(r.x - x)<10 && Math.abs(r.y - y)<10);
            ctx.strokeStyle = detectedBib ? "green" : "red";
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, width, height);
            ctx.font = "18px Arial";
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fillText(p.className + " " + Math.round(p.confidence*100)+"%", x, y-5);

            const key = `${x}_${y}_${width}_${height}`;
            if(!ocrQueue.has(key)){
                ocrQueue.add(key);
                (async () => {
                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = width/2;
                    cropCanvas.height = height/2;
                    const cropCtx = cropCanvas.getContext('2d');
                    cropCtx.drawImage(video, x, y, width, height, 0, 0, cropCanvas.width, cropCanvas.height);
                    const { data: { text } } = await ocrWorker.recognize(cropCanvas);
                    const bib = text.match(/\d{2,6}/)?.[0];
                    if(bib && !results.find(r=>r.bib===bib)){
                        const timestamp = new Date().toLocaleString();
                        results.push({ bib, timestamp, x, y });
                        const row = document.getElementById("resultsTable").insertRow();
                        row.insertCell(0).innerText = bib;
                        row.insertCell(1).innerText = timestamp;
                    }
                    ocrQueue.delete(key);
                })();
            }
        }
    }

    function downloadCSV() {
        let csv = "BIB,Timestamp\n";
        results.forEach(r => csv += `${r.bib},${r.timestamp}\n`);
        const blob = new Blob([csv], {type:"text/csv"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "bib_results.csv";
        a.click();
    }

    startBtn.addEventListener("click", startDetection);
    stopBtn.addEventListener("click", stopDetection);
    window.downloadCSV = downloadCSV;
})();
</script>

</body>
</html>
